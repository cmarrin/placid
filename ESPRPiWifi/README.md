# WiFi Support via ESP8266

## Introduction
The Raspberry Pi Zero W is great little board - $10 for a powerful computer with hardware accelerated graphics and built-in WiFi and Bluetooth. Unfortunately the WiFi (and bluetooth) subsystems are incredibly difficult to work with. The documentation is terrible and you have to upload firmware that is closed source so you only have a binary. It's really designed to be used with Linux. I (and others) have tried to get it working on a bare metal system without much luck.

So I thought about the ESP8266. This is a chip that comes in a variety of form factors. It has great community support, handles the entire ethernet stack, and has a programmable CPU with a well supported toolchain. I've written code for it for several projects and it works really well. Best of all, you can get it for under $2 in some form factors! Pair that with a non-WiFi Raspberry Pi Zero, which costs $5, and you have an even cheaper WiFi enabled system.

The problem is, how do you talk to it? There's already projects [here](https://github.com/JiriBilek/WiFiSpiESP) with code you run on the ESP, interfacing over SPI to a master host. And there's a companion project [here](https://github.com/JiriBilek/WiFiSpi) with code you run on an Arduino to talk to it. But there's one big problem. SPI is a _terrible_ specificiation. At the lowest level it's simply a synchonous interface with a clock line coming from the master and then a data line going to the slave (MOSI) and another one going to the master (MISO). But the ESP layers some command logic on top of that and it doesn't document it very well. I ported the master side code to the Raspberry Pi and could never get it to work. 

So I went back to the drawing board and implemented low level SPI drivers on both the ESP and RPi. With the help of my logic analyzer, I eventually learned that the ESP expects one of 4 command bytes: SentData, ReceiveData, SendStatus and ReceiveStatus. The SendData and ReceiveData commands require an extra byte to be sent after the command, and when you receive data you send dummy bytes from the master and then read the byte back, which is from the slave. The status commands don't require the extra byte and a status message can be 1-4 bytes. After working all this out I wrote basic SPIMaster and SPISlave classes along with some test logic to make sure the interface was working reliably. 

The good news is that I've been able to get reliable communications between the two at up to 8Mbps. That's a megabyte per second, which is not gigabit ethernet rates by any means. But it should do for now. This code is checked in now. In order to use it, you need a specific hardware setup. I'm using a Wemos D1 Mini for the ESP. ESPRPiWifi.ino has a comment showing how to hook it all up. You need to connect a USB to TTL board (like the FTDI) to the Raspberry Pi and connect it to a serial terminal (I use [Serial.app](https://www.decisivetactics.com/products/serial/)). Then connect the Wemos to a second terminal and load up all the code. Then type **test spi** and within 10 seconds go to the RPi terminal and type in the same. It should run the test 50 times and you should not see any errors.
